#summary Explanation of the methods of the VG.Path class

= Introduction =

The Path class wraps a VGPath handle and provides the functionality needed to create, transform, and draw paths.

Note: Path objects have a style attribute which can be used to automatically set the corresponding context parameters when drawing and then restore the old parameters.

= Methods =
*{{{__}}}init{{{__}}}(format=0, datatype=VG_PATH_DATATYPE_F, scale=1.0, bias=0, segment_hint=0, coord_hint=0, capabilities=VG_PATH_CAPABILITY_ALL)*

For the most part, there is no reason to pass the constructor any values besides the defaults. 
  * format corresponds to the path format used internally by OpenVG. 0 indicates the standard format currently.
  * datatype is a constant indicating the datatype used to represent the path coordinates. Other options are VG_PATH_DATATYPE_S_8, VG_PATH_DATATYPE_S_16, and VG_PATH_DATATYPE_32. Certain kinds of paths (such as fonts) fit nicely in smaller datatypes.
  * segment and bias are used together with the datatype to define the valid range of coordinates. A given coordinate v is mapped to v*scale + bias.
  * segment_hint and coord_hint are hints to OpenVG telling it how much space it might need to allocate for a given path. Setting these might help performance a little, but probably won't make a difference.
  * capabilities is a bitwise OR of the various capabilities that paths have (such has appending data, transforming, interpolating, etc). In theory OpenVG can save space if you specify fewer capabilities, but most of the time you'll want to stick with VG_PATH_CAPABILITY_ALL.

*clear(capabilities=VG_PATH_CAPABILITY_ALL)*

Path.clear(capabilities) will empty the path, removing all segments. Additionally, the path capabilities will be reduced to the passed in capabilities parameter. New capabilities cannot be added.

*append(segment)*

Path.append(segment) appends a single path segment to the path. segment must be of the form (command, data) where command is one of the OpenVG path commands and data is a tuple of the corresponding control points.

Example:
{{{
    path = VG.Path()
    path.append((VG_MOVE_TO_ABS, (10.0, 10.0)))
}}}

*extend(segments)*

Path.extend(segments) works just like you would expect list.extend to. It takes either a list of segments formatted like with Path.append or another path and it adds the segments to the path.

Example:
{{{
    path = VG.Path()
    segments = [(VG_MOVE_TO_ABS, ( 10.0, 10.0)),
                (VG_LINE_TO_REL, (  0.0, 20.0)),
                (VG_LINE_TO_REL, ( 20.0,  0.0)),
                (VG_LINE_TO_REL, (-10.0,  0.0)),
                (VG_CLOSE_PATH, ())]
    path.extend(segments)
}}}

*modify(index, data)*

Path.modify(index, data) sets the segment data for segments starting at index to data

Example:
{{{
    #Create a path, then translate it and grow it
    path = VG.Path()
    segments = [(VG_MOVE_TO_ABS, ( 10.0, 10.0)),
                (VG_LINE_TO_REL, (  0.0, 20.0)),
                (VG_LINE_TO_REL, ( 20.0,  0.0)),
                (VG_LINE_TO_REL, (-20.0,  0.0)),
                (VG_CLOSE_PATH, ())]
    path.extend(segments)

    #This changes the initial VG_MOVE_TO_ABS to 100.0,100.0 instead of 10.0,10.0
    path.modify(0, [(100.0, 100.0)])
    #This changes the VG_LINE_TO_RELs to move further
    path.modify(1, [(  0.0, 50.0),
                    ( 50.0,  0.0),
                    (-50.0,  0.0)])
}}}